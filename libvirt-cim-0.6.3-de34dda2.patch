From de34dda20f1e9d88075202ff3257a10cc87fbca6 Mon Sep 17 00:00:00 2001
From: Xu Wang <gesaint@linux.vnet.ibm.com>
Date: Thu, 27 Mar 2014 11:10:35 -0400
Subject: [PATCH 53/60] Set fields in mofs for Controller Device/RASD

Set basic fields for the KVM_Controller instance based on the read XML
from the virtual controller device structure.

Set the various KVM_ControllerRASD fields based on the read XML from
the virtual controller device structure

Signed-off-by: John Ferlan <jferlan@redhat.com>
---
 src/Virt_Device.c | 68 +++++++++++++++++++++++++++++++++++++++++++++++++++++--
 src/Virt_RASD.c   | 57 +++++++++++++++++++++++++++++++++++++++++++++-
 src/svpc_types.h  |  3 ++-
 3 files changed, 124 insertions(+), 4 deletions(-)

diff --git a/src/Virt_Device.c b/src/Virt_Device.c
index 12ae6bd..60465b7 100644
--- a/src/Virt_Device.c
+++ b/src/Virt_Device.c
@@ -1,5 +1,5 @@
 /*
- * Copyright IBM Corp. 2007
+ * Copyright IBM Corp. 2007-2014
  *
  * Authors:
  *  Dan Smith <danms@us.ibm.com>
@@ -366,6 +366,61 @@ static CMPIInstance *input_instance(const CMPIBroker *broker,
         return inst;
 }
 
+static int controller_set_attr(const CMPIBroker *broker,
+                               CMPIInstance *instance,
+                               struct controller_device *dev)
+{
+        const char *type_str;
+
+        type_str = controller_protocol_type_IDToStr(dev->type);
+        if (type_str == NULL) {
+            CU_DEBUG("controller type=%d fails to return string", dev->type);
+            return 0;
+        }
+
+        CMSetProperty(instance, "ProtocolSupported",
+                      (CMPIValue *)&dev->type,
+                      CMPI_uint16);
+
+        if (dev->model)
+            CMSetProperty(instance, "ProtocolDescription",
+                          (CMPIValue *)dev->model,
+                          CMPI_chars);
+
+        return 1;
+}
+
+static CMPIInstance *controller_instance(const CMPIBroker *broker,
+                                         struct controller_device *dev,
+                                         const virDomainPtr dom,
+                                         const char *ns)
+{
+        CMPIInstance *inst;
+        virConnectPtr conn;
+
+        CU_DEBUG("controller_instance");
+
+        conn = virDomainGetConnect(dom);
+        inst = get_typed_instance(broker,
+                                  pfx_from_conn(conn),
+                                  "Controller",
+                                  ns,
+                                  true);
+        if (inst == NULL) {
+                CU_DEBUG("Failed to get instance of %s_Controller",
+                         pfx_from_conn(conn));
+                return NULL;
+        }
+
+
+        if (!controller_set_attr(broker, inst, dev)) {
+                CU_DEBUG("Failed to set contoller attributes of %s_Controller",
+                         pfx_from_conn(conn));
+                return NULL;
+        }
+
+        return inst;
+}
 static int device_set_devid(CMPIInstance *instance,
                             struct virt_device *dev,
                             const virDomainPtr dom)
@@ -488,6 +543,8 @@ static bool device_instances(const CMPIBroker *broker,
         for (i = 0; i < count; i++) {
                 struct virt_device *dev = &devs[i];
 
+                CU_DEBUG("device_instance dev->type=%d", dev->type);
+
                 if (dev->type == CIM_RES_TYPE_NET)
                         instance = net_instance(broker,
                                                 &dev->dev.net,
@@ -516,11 +573,16 @@ static bool device_instances(const CMPIBroker *broker,
                                                     &dev->dev.console,
                                                     dom,
                                                     ns);
-                 else if (dev->type == CIM_RES_TYPE_INPUT)
+                else if (dev->type == CIM_RES_TYPE_INPUT)
                         instance = input_instance(broker,
                                                   &dev->dev.input,
                                                   dom,
                                                   ns);
+                else if (dev->type == CIM_RES_TYPE_CONTROLLER)
+                        instance = controller_instance(broker,
+                                                       &dev->dev.controller,
+                                                       dom,
+                                                       ns);
                 else
                         return false;
 
@@ -555,6 +617,8 @@ uint16_t res_type_from_device_classname(const char *classname)
                 return CIM_RES_TYPE_GRAPHICS;
         else if (strstr(classname, "PointingDevice"))
                 return CIM_RES_TYPE_INPUT;
+        else if (strstr(classname, "Controller"))
+                return CIM_RES_TYPE_CONTROLLER;
         else
                 return CIM_RES_TYPE_UNKNOWN;
 }
diff --git a/src/Virt_RASD.c b/src/Virt_RASD.c
index abfb09f..3c62c2d 100644
--- a/src/Virt_RASD.c
+++ b/src/Virt_RASD.c
@@ -1,5 +1,5 @@
 /*
- * Copyright IBM Corp. 2007, 2013
+ * Copyright IBM Corp. 2007-2014
  *
  * Authors:
  *  Dan Smith <danms@us.ibm.com>
@@ -915,6 +915,51 @@ static CMPIStatus set_input_rasd_params(const struct virt_device *dev,
         return s;
 }
 
+static CMPIStatus set_controller_rasd_params(const CMPIBroker *broker,
+                                             const CMPIObjectPath *ref,
+                                             const struct virt_device *dev,
+                                             CMPIInstance *inst)
+{
+        const char *type_str;
+        CMPIStatus s = {CMPI_RC_OK, NULL};
+
+        type_str = controller_protocol_type_IDToStr(dev->dev.controller.type);
+        if (type_str == NULL) {
+                CU_DEBUG("controller type=%d fails to return string",
+                         dev->type);
+                return s;
+        }
+        CMSetProperty(inst, "OtherResourceType", "controller", CMPI_chars);
+        CMSetProperty(inst, "ResourceSubType",
+                      (CMPIValue *)type_str, CMPI_chars);
+        CMSetProperty(inst, "Index",
+                      (CMPIValue *)&(dev->dev.controller.index), CMPI_uint64);
+
+        if (dev->dev.controller.model)
+            CMSetProperty(inst, "Model",
+                          (CMPIValue *)dev->dev.controller.model, CMPI_chars);
+
+        if (dev->dev.controller.ports)
+            CMSetProperty(inst, "Ports",
+                          (CMPIValue *)dev->dev.controller.ports, CMPI_chars);
+
+        if (dev->dev.controller.vectors)
+            CMSetProperty(inst, "Vectors",
+                          (CMPIValue *)dev->dev.controller.vectors, CMPI_chars);
+
+        if (dev->dev.controller.queues)
+            CMSetProperty(inst, "Queues",
+                          (CMPIValue *)dev->dev.controller.queues, CMPI_chars);
+
+        if (dev->dev.controller.address.ct > 0)
+            set_rasd_device_address(broker,
+                                    ref,
+                                    &dev->dev.controller.address,
+                                    inst);
+
+        return s;
+}
+
 CMPIInstance *rasd_from_vdev(const CMPIBroker *broker,
                                     struct virt_device *dev,
                                     const char *host,
@@ -949,6 +994,9 @@ CMPIInstance *rasd_from_vdev(const CMPIBroker *broker,
         } else if (dev->type == CIM_RES_TYPE_INPUT) {
                 type = CIM_RES_TYPE_INPUT;
                 base = "InputResourceAllocationSettingData";
+        } else if (dev->type == CIM_RES_TYPE_CONTROLLER) {
+                type = CIM_RES_TYPE_OTHER;
+                base = "ControllerResourceAllocationSettingData";
         } else {
                 return NULL;
         }
@@ -1004,6 +1052,8 @@ CMPIInstance *rasd_from_vdev(const CMPIBroker *broker,
                 s = set_input_rasd_params(dev, inst);
         } else if (dev->type == CIM_RES_TYPE_CONSOLE) {
                 s = set_console_rasd_params(dev, inst);
+        } else if (dev->type == CIM_RES_TYPE_CONTROLLER) {
+                s = set_controller_rasd_params(broker, ref, dev, inst);
         }
 
         /* FIXME: Put the HostResource in place */
@@ -1138,6 +1188,8 @@ CMPIrc res_type_from_rasd_classname(const char *cn, uint16_t *type)
                *type = CIM_RES_TYPE_IMAGE;
        else if (STREQ(base, "ConsoleResourceAllocationSettingData"))
                *type = CIM_RES_TYPE_CONSOLE;
+       else if (STREQ(base, "ControllerResourceAllocationSettingData"))
+               *type = CIM_RES_TYPE_CONTROLLER;
        else
                goto out;
 
@@ -1175,6 +1227,9 @@ CMPIrc rasd_classname_from_type(uint16_t type, const char **classname)
         case CIM_RES_TYPE_INPUT:
                 *classname = "InputResourceAllocationSettingData";
                 break;
+        case CIM_RES_TYPE_CONTROLLER:
+                *classname = "ControllerResourceAllocationSettingData";
+                break;
         default:
                 rc = CMPI_RC_ERR_FAILED;
         }
diff --git a/src/svpc_types.h b/src/svpc_types.h
index d9f8032..6270233 100644
--- a/src/svpc_types.h
+++ b/src/svpc_types.h
@@ -42,7 +42,7 @@
 #define CIM_RES_TYPE_EMU        32770
 #define CIM_RES_TYPE_CONTROLLER 32771
 
-#define CIM_RES_TYPE_COUNT 7
+#define CIM_RES_TYPE_COUNT 8
 const static int cim_res_types[CIM_RES_TYPE_COUNT] = 
   {CIM_RES_TYPE_NET,
    CIM_RES_TYPE_DISK,
@@ -51,6 +51,7 @@ const static int cim_res_types[CIM_RES_TYPE_COUNT] =
    CIM_RES_TYPE_GRAPHICS,
    CIM_RES_TYPE_INPUT,
    CIM_RES_TYPE_CONSOLE,
+   CIM_RES_TYPE_CONTROLLER,
   };
 
 #define CIM_VSSD_RECOVERY_NONE       2
-- 
2.1.0

