From 4954aa8c9e659fe593cf368c82a62124754d4c9c Mon Sep 17 00:00:00 2001
From: Xu Wang <gesaint@linux.vnet.ibm.com>
Date: Tue, 18 Mar 2014 08:52:53 -0400
Subject: [PATCH 50/60] Add virtual controller device types

Add data and strutures for a virtual controller device

Signed-off-by: John Ferlan <jferlan@redhat.com>
---
 libxkutil/device_parsing.h |  17 +++++-
 src/svpc_types.h           | 129 ++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 144 insertions(+), 2 deletions(-)

diff --git a/libxkutil/device_parsing.h b/libxkutil/device_parsing.h
index a92e223..afddc1d 100644
--- a/libxkutil/device_parsing.h
+++ b/libxkutil/device_parsing.h
@@ -1,5 +1,5 @@
 /*
- * Copyright IBM Corp. 2007, 2013
+ * Copyright IBM Corp. 2007-2014
  *
  * Authors:
  *  Dan Smith <danms@us.ibm.com>
@@ -163,6 +163,17 @@ struct input_device {
         char *bus;
 };
 
+#define CONTROLLER_INDEX_NOT_SET -1
+struct controller_device {
+        uint16_t type;
+        uint64_t index;
+        char *model;
+        char *ports;
+        char *vectors;
+        char *queues;
+        struct device_address address;
+};
+
 struct virt_device {
         uint16_t type;
         union {
@@ -174,6 +185,7 @@ struct virt_device {
                 struct graphics_device graphics;
                 struct console_device console;
                 struct input_device input;
+                struct controller_device controller;
         } dev;
         char *id;
 };
@@ -249,6 +261,9 @@ struct domain {
 
         struct virt_device *dev_vcpu;
         int dev_vcpu_ct;
+
+        struct virt_device *dev_controller;
+        int dev_controller_ct;
 };
 
 struct virt_device *virt_device_dup(struct virt_device *dev);
diff --git a/src/svpc_types.h b/src/svpc_types.h
index 404e428..d9f8032 100644
--- a/src/svpc_types.h
+++ b/src/svpc_types.h
@@ -1,5 +1,5 @@
 /*
- * Copyright IBM Corp. 2007, 2013
+ * Copyright IBM Corp. 2007-2014
  *
  * Authors:
  *  Dan Smith <danms@us.ibm.com>
@@ -24,6 +24,9 @@
 
 #define CIM_OPERATIONAL_STATUS 2
 
+/* From the ResourceType list for CIM_ResourceAllocationSettingData.html
+ * Found on http://schemas.dmtf.org/wbem/cim-html/2.31.0
+ */
 #define CIM_RES_TYPE_ALL        0
 #define CIM_RES_TYPE_OTHER      1
 #define CIM_RES_TYPE_PROC       3
@@ -33,9 +36,11 @@
 #define CIM_RES_TYPE_GRAPHICS   24
 #define CIM_RES_TYPE_INPUT      13 
 #define CIM_RES_TYPE_UNKNOWN    1000
+/* libvirt-cim specific values can start here */
 #define CIM_RES_TYPE_IMAGE      32768 
 #define CIM_RES_TYPE_CONSOLE    32769
 #define CIM_RES_TYPE_EMU        32770
+#define CIM_RES_TYPE_CONTROLLER 32771
 
 #define CIM_RES_TYPE_COUNT 7
 const static int cim_res_types[CIM_RES_TYPE_COUNT] = 
@@ -266,4 +271,126 @@ static inline const char* chardev_source_type_IDToStr(int type)
         return type_str;
 }
 
+/* enum for Controller ProtocolSupported values
+ *
+ * From the ProtocolSupported list for CIM_Controller.html
+ * Found on http://schemas.dmtf.org/wbem/cim-html/2.31.0
+ */
+enum CIM_controller_protocol_type {
+        CIM_CONTROLLER_PROTOCOL_TYPE_OTHER = 1,
+        CIM_CONTROLLER_PROTOCOL_TYPE_UNKNOWN = 2,
+        CIM_CONTROLLER_PROTOCOL_TYPE_EISA = 3,
+        CIM_CONTROLLER_PROTOCOL_TYPE_ISA = 4,
+        CIM_CONTROLLER_PROTOCOL_TYPE_PCI = 5,
+        CIM_CONTROLLER_PROTOCOL_TYPE_ATA = 6,
+        CIM_CONTROLLER_PROTOCOL_TYPE_FD = 7,
+        CIM_CONTROLLER_PROTOCOL_TYPE_1496 = 8,
+        CIM_CONTROLLER_PROTOCOL_TYPE_SCSI_PI = 9,
+        CIM_CONTROLLER_PROTOCOL_TYPE_SCSI_FC = 10,
+        CIM_CONTROLLER_PROTOCOL_TYPE_SCSI_SB = 11,
+        CIM_CONTROLLER_PROTOCOL_TYPE_SCSI_SB2 = 12,
+        CIM_CONTROLLER_PROTOCOL_TYPE_SCSI_SSA = 13,
+        CIM_CONTROLLER_PROTOCOL_TYPE_VESA = 14,
+        CIM_CONTROLLER_PROTOCOL_TYPE_PCMCIA = 15,
+        CIM_CONTROLLER_PROTOCOL_TYPE_USB = 16,
+        CIM_CONTROLLER_PROTOCOL_TYPE_PP = 17,
+        CIM_CONTROLLER_PROTOCOL_TYPE_ESCON = 18,
+        CIM_CONTROLLER_PROTOCOL_TYPE_DIAG = 19,
+        CIM_CONTROLLER_PROTOCOL_TYPE_I2C = 20,
+        CIM_CONTROLLER_PROTOCOL_TYPE_POWER = 21,
+        CIM_CONTROLLER_PROTOCOL_TYPE_HIPPI = 22,
+        CIM_CONTROLLER_PROTOCOL_TYPE_MULTIBUS = 23,
+        CIM_CONTROLLER_PROTOCOL_TYPE_VME = 24,
+        CIM_CONTROLLER_PROTOCOL_TYPE_IPI = 25,
+        CIM_CONTROLLER_PROTOCOL_TYPE_IEEE488 = 26,
+        CIM_CONTROLLER_PROTOCOL_TYPE_RS232 = 27,
+        CIM_CONTROLLER_PROTOCOL_TYPE_IEEE8023_10BASE5 = 28,
+        CIM_CONTROLLER_PROTOCOL_TYPE_IEEE8023_10BASE2 = 29,
+        CIM_CONTROLLER_PROTOCOL_TYPE_IEEE8023_1BASE5 = 30,
+        CIM_CONTROLLER_PROTOCOL_TYPE_IEEE8023_10BROAD36 = 31,
+        CIM_CONTROLLER_PROTOCOL_TYPE_IEEE8023_100BASEVG = 32,
+        CIM_CONTROLLER_PROTOCOL_TYPE_TOKENRING = 33,
+        CIM_CONTROLLER_PROTOCOL_TYPE_ANSIX3T9 = 34,
+        CIM_CONTROLLER_PROTOCOL_TYPE_MCA = 35,
+        CIM_CONTROLLER_PROTOCOL_TYPE_ESDI = 36,
+        CIM_CONTROLLER_PROTOCOL_TYPE_IDE = 37,
+        CIM_CONTROLLER_PROTOCOL_TYPE_CMD = 38,
+        CIM_CONTROLLER_PROTOCOL_TYPE_ST506 = 39,
+        CIM_CONTROLLER_PROTOCOL_TYPE_DSSI = 40,
+        CIM_CONTROLLER_PROTOCOL_TYPE_QIC2 = 41,
+        CIM_CONTROLLER_PROTOCOL_TYPE_ENH_ATA = 42,
+        CIM_CONTROLLER_PROTOCOL_TYPE_AGP = 43,
+        CIM_CONTROLLER_PROTOCOL_TYPE_TWIRP = 44,
+        CIM_CONTROLLER_PROTOCOL_TYPE_FIR = 45,
+        CIM_CONTROLLER_PROTOCOL_TYPE_SIR = 46,
+        CIM_CONTROLLER_PROTOCOL_TYPE_IRBUS = 47,
+        CIM_CONTROLLER_PROTOCOL_TYPE_SATA = 48,
+        /* libvirt specific */
+        CIM_CONTROLLER_PROTOCOL_TYPE_CCID = 32678,
+        CIM_CONTROLLER_PROTOCOL_TYPE_VIRTIO_SERIAL = 32769,
+};
+
+static inline int controller_protocol_type_StrToID(const char *type_str)
+{
+        int rc = CIM_CONTROLLER_PROTOCOL_TYPE_UNKNOWN;
+
+        if (type_str == NULL)
+                return rc;
+
+        if (STREQC(type_str, "ide"))
+            rc = CIM_CONTROLLER_PROTOCOL_TYPE_IDE;
+        else if (STREQC(type_str, "fdc"))
+            rc = CIM_CONTROLLER_PROTOCOL_TYPE_FD;
+        else if (STREQC(type_str, "scsi"))
+            rc = CIM_CONTROLLER_PROTOCOL_TYPE_SCSI_SSA; /* REVISIT */
+        else if (STREQC(type_str, "sata"))
+            rc = CIM_CONTROLLER_PROTOCOL_TYPE_SATA;
+        else if (STREQC(type_str, "ccid"))
+            rc = CIM_CONTROLLER_PROTOCOL_TYPE_CCID;
+        else if (STREQC(type_str, "virtio-serial"))
+            rc = CIM_CONTROLLER_PROTOCOL_TYPE_VIRTIO_SERIAL;
+        else if (STREQC(type_str, "pci"))
+            rc = CIM_CONTROLLER_PROTOCOL_TYPE_PCI;
+        else if (STREQC(type_str, "usb"))
+            rc = CIM_CONTROLLER_PROTOCOL_TYPE_USB;
+
+        return rc;
+}
+
+static inline const char* controller_protocol_type_IDToStr(int type)
+{
+        char *type_str = NULL;
+
+        switch (type)
+        {
+        case CIM_CONTROLLER_PROTOCOL_TYPE_IDE:
+                type_str = "ide";
+                break;
+        case CIM_CONTROLLER_PROTOCOL_TYPE_FD:
+                type_str = "fdc";
+                break;
+        case CIM_CONTROLLER_PROTOCOL_TYPE_SCSI_SSA:
+                type_str = "scsi";
+                break;
+        case CIM_CONTROLLER_PROTOCOL_TYPE_SATA:
+                type_str = "sata";
+                break;
+        case CIM_CONTROLLER_PROTOCOL_TYPE_CCID:
+                type_str = "ccid";
+                break;
+        case CIM_CONTROLLER_PROTOCOL_TYPE_VIRTIO_SERIAL:
+                type_str = "virtio-serial";
+                break;
+        case CIM_CONTROLLER_PROTOCOL_TYPE_PCI:
+                type_str = "pci";
+                break;
+        case CIM_CONTROLLER_PROTOCOL_TYPE_USB:
+                type_str = "usb";
+                break;
+        default:
+                break;
+        }
+        return type_str;
+}
+
 #endif
-- 
2.1.0

